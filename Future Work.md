# Future Work

0. This is pretty minor, but I need a litle time to make sure that the file specified for output
can be created if it does not exist yet.
1. Because of my rushed fix for spaces, I needed to process commands with commas versus and/ors separately and added some lines of code. In the future, I would like to find a way to parse them all together and have the modules using these parsed commands (Delete, Insert, Selects, Searches, Finds, Updates) use one main streamlined process for processing commands (right now, for Delete and Selects, I use two avenues, which I think I could combine with more time).
2. More and more consolidation is nice, as is the need for fewer modules and fewer lines of code as they will hopefully be more robust, provided they still work. One modification that could help is decrlaring an abstract class for the different commands, and then having the commands themselves be derived classes, as their structures as implemented are already similar.
3. If I had more time, I would test out more random, junk inputs, for now at least some of the burden is still on the user. I try catching erroneous ones and print usages, so for most of my testing so far, the user will likely know what the issue might be.
4. I could always use nice, efficient parsers! I manually examine the code, but it would be nice to have a parser help me directly jump to the case and have the process be more automated.
6. I would like to better use typesets for efficiency, such as first checking if the provided column type for Selects/Deletes are in an existing type and that way if it isn't, we can ignore the command and let the user know more quickly. Additionally, we can more quickly scan through Searches/Finds for more likely candidates that meet the search criteria for the cases where the user specifies a candidate column type.
7. Because I caught that renaming may not necessarily be saved in the storage file late, I quickly added a snippet that when saving, to add the renamed rows to the updated rows and have the storage file updated that way. There is probably a more efficient way to combine these changes.
8. I caught this pretty late also, but the generalization of format is far from complete. It seems that an outer structure of a dictionary is more likely to be supported, and I had trouble with lists, and parsing for nested data does not quite work yet for the specific columns because of the return value of the parser itself. It is hard to work with that data, so it is grabbing the correct output in the program, though we cannot see it just yet.
9. Part of this is - You will eventually also specify what the data and column types (a way to label data such that each element within the entry (or row, as it will be called in this program) is assigned a label, making key value store commands such as selects easier â€“ they are basically keys assigned to each of the items in each entry) are before loading the data. This is not quite polished just yet.